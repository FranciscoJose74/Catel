<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
	var typeCodes = Enum.GetValues(typeof(TypeCode));
#>

//------------------------------------------------------------------------------ 
// <auto-generated> 
// This code was generated by a tool. 
// 
// Changes to this file may cause incorrect behavior and will be lost if 
// the code is regenerated. 
// </auto-generated> 
//------------------------------------------------------------------------------


namespace Catel.Data
{
    using Catel.Logging;
    using Catel.Reflection;
    using System;
    using System.ComponentModel;
    using System.Linq;
    using System.Reflection;

    public partial class ModelBase
    {
        /// <summary>
        /// Registers a property that will be automatically handled by this object.
        /// </summary>
        /// <param name="name">Name of the property.</param>
        /// <param name="type">Type of the property.</param>
        /// <param name="defaultValue">Default value of the property.</param>
        /// <param name="propertyChangedEventHandler">The property changed event handler.</param>
        /// <param name="includeInSerialization">if set to <c>true</c>, the property should be included in the serialization.</param>
        /// <param name="includeInBackup">if set to <c>true</c>, the property should be included in the backup when handling IEditableObject.</param>
        /// <param name="isModelBaseProperty">if set to <c>true</c>, the property is declared by the <see cref="ModelBase"/>.</param>
        /// <returns>
        /// <see cref="PropertyData"/> containing the property information.
        /// </returns>
        /// <exception cref="ArgumentException">The <paramref name="name"/> is <c>null</c> or whitespace.</exception>
        public static IPropertyData RegisterPropertyNonGeneric(string name, Type type, object defaultValue = null,
            EventHandler<PropertyChangedEventArgs> propertyChangedEventHandler = null, bool includeInSerialization = true,
            bool includeInBackup = true, bool isModelBaseProperty = false)
        {
            return RegisterPropertyNonGeneric(name, type, () => defaultValue, propertyChangedEventHandler, includeInSerialization, includeInBackup, isModelBaseProperty);
        }

        /// <summary>
        /// Registers a property that will be automatically handled by this object.
        /// </summary>
        /// <param name="name">Name of the property.</param>
        /// <param name="type">Type of the property.</param>
        /// <param name="createDefaultValue">Default value of the property.</param>
        /// <param name="propertyChangedEventHandler">The property changed event handler.</param>
        /// <param name="includeInSerialization">if set to <c>true</c>, the property should be included in the serialization.</param>
        /// <param name="includeInBackup">if set to <c>true</c>, the property should be included in the backup when handling IEditableObject.</param>
        /// <param name="isModelBaseProperty">if set to <c>true</c>, the property is declared by the <see cref="ModelBase"/>.</param>
        /// <returns>
        /// <see cref="PropertyData"/> containing the property information.
        /// </returns>
        /// <exception cref="ArgumentException">The <paramref name="name"/> is <c>null</c> or whitespace.</exception>
        public static IPropertyData RegisterPropertyNonGeneric(string name, Type type, Func<object> createDefaultValue,
            EventHandler<PropertyChangedEventArgs> propertyChangedEventHandler = null, bool includeInSerialization = true,
            bool includeInBackup = true, bool isModelBaseProperty = false)
        {
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull | typeCode == TypeCode.Object)
	{
		continue;
	}

    string storageType = "Dictionary<string, " + typeCode.ToString() + ">";
	string storageName = "_" + typeCode.ToString().ToLowerInvariant() + "Storage";

#>
            if (type == typeof(<#= typeCode.ToString() #>))
            {
                Func<<#= typeCode.ToString() #>> createTypedDefaultValue = null;

                if (createDefaultValue is Func<object> func)
                {
                    createTypedDefaultValue = new Func<<#= typeCode.ToString() #>>(() => 
                    {
                        var finalDefaultValue = createDefaultValue();
                        if (finalDefaultValue is <#= typeCode.ToString() #> typedValue)
                        {
                            return typedValue;
                        }

                        return default(<#= typeCode.ToString() #>);
                    });
                }
                else
                {
                    // Just return the default
                    createTypedDefaultValue = new Func<<#= typeCode.ToString() #>>(() => 
                    {
                        return default(<#= typeCode.ToString() #>);
                    });
                }

                return RegisterProperty<<#= typeCode.ToString() #>>(name, createTypedDefaultValue, propertyChangedEventHandler,
                    includeInSerialization, includeInBackup, isModelBaseProperty);
            }

<#
}
#>
            // Backwards compatibility, slow but required. Uses this method:

            // private static IPropertyData RegisterProperty<TValue>(string name, Func<TValue> createDefaultValue = null,
            //    EventHandler<PropertyChangedEventArgs> propertyChangedEventHandler = null, bool includeInSerialization = true,
            //    bool includeInBackup = true, bool isModelBaseProperty = false)

            MethodInfo registerPropertyMethod = null;

            foreach (var methodInfo in typeof(ModelBase).GetMethodsEx(BindingFlagsHelper.GetFinalBindingFlags(true, true, true)))
            {
                if (!methodInfo.IsGenericMethod)
                {
                    continue;
                }

                if (methodInfo.Name != nameof(RegisterProperty))
                {
                    continue;
                }

                var parameters = methodInfo.GetParameters();
                if (parameters.Length != 6)
                {
                    continue;
                }

                var parameterInfo = parameters[1];
                if (parameterInfo.ParameterType != typeof(Func<object>))
                {
                    continue;
                }

                registerPropertyMethod = methodInfo;
                break;
            }

            var finalMethod = registerPropertyMethod.MakeGenericMethod(type);
            var propertyData = (IPropertyData)finalMethod.Invoke(null, new object[] { name, createDefaultValue, propertyChangedEventHandler, includeInSerialization, includeInBackup, isModelBaseProperty });
            return propertyData;
        }

        protected void SetDefaultValueToPropertyBag(IPropertyData propertyData)
        {
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull | typeCode == TypeCode.Object)
	{
		continue;
	}

    string storageType = "Dictionary<string, " + typeCode.ToString() + ">";
	string storageName = "_" + typeCode.ToString().ToLowerInvariant() + "Storage";

#>
            if (propertyData.Type == typeof(<#= typeCode.ToString() #>))
            {
                SetValueToPropertyBag<<#= typeCode.ToString() #>>(propertyData.Name, propertyData.GetDefaultValue<<#= typeCode.ToString() #>>());
                return;
            }

<#
}
#>
            // Fallback to object / class instance (already boxed)
            SetValueToPropertyBag<object>(propertyData.Name, propertyData.GetDefaultValue<object>());
        }
    }
}