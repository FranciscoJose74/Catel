<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
	var typeCodes = Enum.GetValues(typeof(TypeCode));
#>

//------------------------------------------------------------------------------ 
// <auto-generated> 
// This code was generated by a tool. 
// 
// Changes to this file may cause incorrect behavior and will be lost if 
// the code is regenerated. 
// </auto-generated> 
//------------------------------------------------------------------------------


namespace Catel.Data
{
    using System;
    using System.Linq;
    using System.Collections.Generic;
    using Catel.Logging;
    using Catel.Reflection;

    public partial class TypedPropertyBag
    {
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull)
	{
		continue;
	}

    string storageType = "Dictionary<string, " + typeCode.ToString() + ">";
	string storageName = "_" + typeCode.ToString().ToLowerInvariant() + "Storage";

#>
        private <#= storageType #> <#= storageName #>;
<#
}
#>

<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull)
	{
		continue;
	}

    string storageType = "Dictionary<string, " + typeCode.ToString() + ">";
	string storageName = "_" + typeCode.ToString().ToLowerInvariant() + "Storage";

#>
        protected <#= storageType #> Get<#= typeCode.ToString() #>Storage()
        {
            if (<#= storageName #> is null)
            {
                <#= storageName #> = new <#= storageType #>();
            }

            return <#= storageName #>;
        }

<#
}
#>

        public override TValue GetValue<TValue>(string name, TValue defaultValue = default)
        {
            Argument.IsNotNullOrWhitespace(nameof(name), name);

            // Get from the right dictionary and see if we need to convert to TValue
            var propertyType = GetRegisteredPropertyType(name);
            if (propertyType is null)
            {
                // Not registered!
                return defaultValue;
            }

            var targetType = typeof(TValue);

            // TODO: Get from right dictionary and cast / convert if needed

<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull || typeCode == TypeCode.Object)
	{
		continue;
	}
#>
            if (targetType == typeof(<#= typeCode.ToString() #>))
            {
                var storage = Get<#= typeCode.ToString() #>Storage();

                lock (storage)
                {
                    if (storage.TryGetValue(name, out var bagValue))
                    {
                        var tr = __makeref(bagValue);
                        var value = __refvalue(tr, TValue);
                        return value;
                    }
                }

                return default;
            }
<#
}
#>

            // Fallback to object store
            {
                var storage = GetObjectStorage();

                lock (storage)
                {
                    if (storage.TryGetValue(name, out var bagValue))
                    {
                        var tr = __makeref(bagValue);
                        var value = __refvalue(tr, TValue);
                        return value;
                    }
                }

                return default;
            }
        }

        public override void SetValue<TValue>(string name, TValue value)
        {
            Argument.IsNotNullOrWhitespace(nameof(name), name);

            var stored = false;
            var raisePropertyChanged = false;

            var targetType = typeof(TValue);
            if (typeof(TValue) == typeof(object)) 
            {
                // Fastest path, if users use SetValue<object>(), we might need to convert
                var propertyType = GetRegisteredPropertyType(name);
                if (propertyType is null)
                {
                    // Just store as object
                    EnsureIntegrity(name, typeof(TValue));

                    var tr = __makeref(value);
                    var bagValue = __refvalue(tr, object);
                    var storage = GetObjectStorage();

                    lock (storage)
                    {
                        if (!storage.TryGetValue(name, out var propertyValue) || !ObjectHelper.AreEqualReferences(propertyValue, bagValue))
                        {
                            storage[name] = bagValue;
                            raisePropertyChanged = true;
                        }
                    }

                    stored = true;
                }
                else
                {
                    // Slowest path, we need to cast and store in the right dictionary
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull || typeCode == TypeCode.Object)
	{
		continue;
	}
#>
                    if (propertyType == typeof(<#= typeCode.ToString() #>))
                    {
                        var castValue = (<#= typeCode.ToString() #>)(object)value;
                        SetValue<<#= typeCode.ToString() #>>(name, castValue);
                        return;
                    }

<#
}
#>
                    throw Log.ErrorAndCreateException<NotSupportedException>($"Property '{name}' is set as '{targetType.FullName}' but was registered as '{propertyType.FullName}' and cannot be casted / converted automatically");
                }
            }
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull || typeCode == TypeCode.Object)
	{
		continue;
	}
#>
            if (!stored && targetType == typeof(<#= typeCode.ToString() #>))
            {
                EnsureIntegrity(name, typeof(TValue));

                var tr = __makeref(value);
                var bagValue = __refvalue(tr, <#= typeCode.ToString() #>);
                var storage = Get<#= typeCode.ToString() #>Storage();

                lock (storage)
                {
                    if (!storage.TryGetValue(name, out var propertyValue) || propertyValue != bagValue)
                    {
                        storage[name] = bagValue;
                        raisePropertyChanged = true;
                    }
                }

                stored = true;
            }

<#
}
#>

            if (raisePropertyChanged)
            {
                RaisePropertyChanged(name);
            }
        }

        public override Dictionary<string, object> GetAllProperties()
        {
            var values = new Dictionary<string, object>();

            // Note: don't use methods, we don't want to lazy-instantiate the storage
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull || typeCode == TypeCode.Object)
	{
		continue;
	}

    var storageName = typeCode.ToString().ToLowerInvariant() + "Storage";
#>
            var <#= storageName #> = _<#= storageName #>;
            if (<#= storageName #> != null)
            {
                 // Unfortunately we have to box to object here...
                 foreach (var propertyPair in <#= storageName #>)
                 {
                     values[propertyPair.Key] = BoxingCache.GetBoxedValue(propertyPair.Value);
                 }
            }

<#
}
#>

            var objectStorage = _objectStorage;
            if (objectStorage != null)
            {
                foreach (var propertyPair in objectStorage)
                {
                    values[propertyPair.Key] = propertyPair.Value;
                }
            }

            return values;
        }
    }
}