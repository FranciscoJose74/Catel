//------------------------------------------------------------------------------ 
// <auto-generated> 
// This code was generated by a tool. 
// 
// Changes to this file may cause incorrect behavior and will be lost if 
// the code is regenerated. 
// </auto-generated> 
//------------------------------------------------------------------------------

namespace Catel.Reflection
{
	using System;

	public static partial class CastExtensions
	{
        public static TValue CastTo<TValue>(this object value)
        {
            return (TValue)value;
        }

        public static TValue CastTo<TValue>(this Boolean value)
        {
            if (typeof(TValue) == typeof(Boolean)
                || typeof(TValue) == typeof(Boolean?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static Boolean CastToBoolean<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is Boolean)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return (Boolean)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToBoolean((object)value);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToBoolean(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToBoolean(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'Boolean'");
        }

        public static TValue CastTo<TValue>(this Char value)
        {
            if (typeof(TValue) == typeof(Char)
                || typeof(TValue) == typeof(Char?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static Char CastToChar<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is Char)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return (Char)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToChar((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToChar(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToChar(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'Char'");
        }

        public static TValue CastTo<TValue>(this SByte value)
        {
            if (typeof(TValue) == typeof(SByte)
                || typeof(TValue) == typeof(SByte?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static SByte CastToSByte<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is SByte)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return (SByte)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToSByte((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToSByte(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToSByte(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'SByte'");
        }

        public static TValue CastTo<TValue>(this Byte value)
        {
            if (typeof(TValue) == typeof(Byte)
                || typeof(TValue) == typeof(Byte?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static Byte CastToByte<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is Byte)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return (Byte)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToByte((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToByte(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToByte(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'Byte'");
        }

        public static TValue CastTo<TValue>(this Int16 value)
        {
            if (typeof(TValue) == typeof(Int16)
                || typeof(TValue) == typeof(Int16?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static Int16 CastToInt16<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is Int16)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return (Int16)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToInt16((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToInt16(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToInt16(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'Int16'");
        }

        public static TValue CastTo<TValue>(this UInt16 value)
        {
            if (typeof(TValue) == typeof(UInt16)
                || typeof(TValue) == typeof(UInt16?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static UInt16 CastToUInt16<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is UInt16)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return (UInt16)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToUInt16((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToUInt16(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToUInt16(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'UInt16'");
        }

        public static TValue CastTo<TValue>(this Int32 value)
        {
            if (typeof(TValue) == typeof(Int32)
                || typeof(TValue) == typeof(Int32?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static Int32 CastToInt32<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is Int32)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return (Int32)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToInt32((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToInt32(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToInt32(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'Int32'");
        }

        public static TValue CastTo<TValue>(this UInt32 value)
        {
            if (typeof(TValue) == typeof(UInt32)
                || typeof(TValue) == typeof(UInt32?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static UInt32 CastToUInt32<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is UInt32)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return (UInt32)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToUInt32((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToUInt32(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToUInt32(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'UInt32'");
        }

        public static TValue CastTo<TValue>(this Int64 value)
        {
            if (typeof(TValue) == typeof(Int64)
                || typeof(TValue) == typeof(Int64?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static Int64 CastToInt64<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is Int64)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return (Int64)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToInt64((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToInt64(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToInt64(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'Int64'");
        }

        public static TValue CastTo<TValue>(this UInt64 value)
        {
            if (typeof(TValue) == typeof(UInt64)
                || typeof(TValue) == typeof(UInt64?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static UInt64 CastToUInt64<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is UInt64)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return (UInt64)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToUInt64((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToUInt64(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToUInt64(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'UInt64'");
        }

        public static TValue CastTo<TValue>(this Single value)
        {
            if (typeof(TValue) == typeof(Single)
                || typeof(TValue) == typeof(Single?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static Single CastToSingle<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is Single)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return (Single)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToSingle((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToSingle(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToSingle(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'Single'");
        }

        public static TValue CastTo<TValue>(this Double value)
        {
            if (typeof(TValue) == typeof(Double)
                || typeof(TValue) == typeof(Double?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static Double CastToDouble<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is Double)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return (Double)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToDouble((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToDouble(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToDouble(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'Double'");
        }

        public static TValue CastTo<TValue>(this Decimal value)
        {
            if (typeof(TValue) == typeof(Decimal)
                || typeof(TValue) == typeof(Decimal?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static Decimal CastToDecimal<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is Decimal)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return (Decimal)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToDecimal((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToDecimal(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToDecimal(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'Decimal'");
        }

        public static TValue CastTo<TValue>(this DateTime value)
        {
            if (typeof(TValue) == typeof(DateTime)
                || typeof(TValue) == typeof(DateTime?)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static DateTime CastToDateTime<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is DateTime)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return (DateTime)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToDateTime((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToDateTime(castValue);
            }

            if (type == typeof(String))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return Convert.ToDateTime(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'DateTime'");
        }

        public static TValue CastTo<TValue>(this String value)
        {
            if (typeof(TValue) == typeof(String)
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static String CastToString<TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is String)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, String);
                return (String)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.ToString((object)value);
            }

            if (type == typeof(Boolean))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Boolean);
                return Convert.ToString(castValue);
            }

            if (type == typeof(Char))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Char);
                return Convert.ToString(castValue);
            }

            if (type == typeof(SByte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, SByte);
                return Convert.ToString(castValue);
            }

            if (type == typeof(Byte))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Byte);
                return Convert.ToString(castValue);
            }

            if (type == typeof(Int16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int16);
                return Convert.ToString(castValue);
            }

            if (type == typeof(UInt16))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt16);
                return Convert.ToString(castValue);
            }

            if (type == typeof(Int32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int32);
                return Convert.ToString(castValue);
            }

            if (type == typeof(UInt32))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt32);
                return Convert.ToString(castValue);
            }

            if (type == typeof(Int64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Int64);
                return Convert.ToString(castValue);
            }

            if (type == typeof(UInt64))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, UInt64);
                return Convert.ToString(castValue);
            }

            if (type == typeof(Single))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Single);
                return Convert.ToString(castValue);
            }

            if (type == typeof(Double))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Double);
                return Convert.ToString(castValue);
            }

            if (type == typeof(Decimal))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, Decimal);
                return Convert.ToString(castValue);
            }

            if (type == typeof(DateTime))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, DateTime);
                return Convert.ToString(castValue);
            }

            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to 'String'");
        }

	}
}