<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
	var typeCodes = Enum.GetValues(typeof(TypeCode));
#>
//------------------------------------------------------------------------------ 
// <auto-generated> 
// This code was generated by a tool. 
// 
// Changes to this file may cause incorrect behavior and will be lost if 
// the code is regenerated. 
// </auto-generated> 
//------------------------------------------------------------------------------

namespace Catel.Reflection
{
	using System;

	public static partial class CastExtensions
	{
        public static TValue CastTo<TValue>(this object value)
        {
            return (TValue)value;
        }

<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull || typeCode == TypeCode.Object)
	{
		continue;
	}

#>
        public static TValue CastTo<TValue>(this <#= typeCode.ToString() #> value)
        {
            if (typeof(TValue) == typeof(<#= typeCode.ToString() #>)
<# 
    if (typeCode != TypeCode.String)
    {
#>
                || typeof(TValue) == typeof(<#= typeCode.ToString() #>?)
<#
    }
#>
                )
            {
                // This code is equivalent to (TValue)(object)value, but without the boxing
                var tr = __makeref(value);
                var castValue = __refvalue(tr, TValue);
                return castValue;
            }

            // Fallback mechanism for now
            return (TValue)(object)value;
        }

        public static <#= typeCode.ToString() #> CastTo<#= typeCode.ToString() #><TValue>(this TValue value)
        {
            // Fastest path out, check same type
            if (value is <#= typeCode.ToString() #>)
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, <#= typeCode.ToString() #>);
                return (<#= typeCode.ToString() #>)castValue;
            }

            var type = typeof(TValue);

            if (type == typeof(object))
            {
                return Convert.To<#= typeCode.ToString() #>((object)value);
            }

<# 
    foreach (TypeCode subTypeCode in typeCodes) 
    {
	    if (subTypeCode == TypeCode.Empty || subTypeCode == TypeCode.DBNull || subTypeCode == TypeCode.Object || subTypeCode == typeCode)
	    {
		    continue;
	    }

#>
            if (type == typeof(<#= subTypeCode.ToString() #>))
            {
                // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                var tr = __makeref(value);
                var castValue = __refvalue(tr, <#= subTypeCode.ToString() #>);
                return Convert.To<#= typeCode.ToString() #>(castValue);
            }

<#
    }
#>
            throw new NotSupportedException($"Cound not cast or convert '{value?.ToString()}' to '<#= typeCode.ToString() #>'");
        }

<# } #>
	}
}